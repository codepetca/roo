<script>
  // Server-side cache management (using AppScript PropertiesService)

  // Global application state - now cache-based
  const AppState = {
    // Dashboard cache (contains all data)
    dashboardCache: null,
    
    // Current UI state
    currentClassroom: null,
    currentAssignment: null,
    selectedSubmissions: new Set(),
    currentSubmissionIndex: -1,
    lastAction: null,
    
    // Cache status
    cacheLoading: false,
    cacheError: null
  };

  // Initialize application on page load
  document.addEventListener('DOMContentLoaded', function() {
    console.log('Roo Teacher Grading Portal - Initializing...');
    initializeApp();
  });

  // Debug function for clearing cache (callable from console)
  window.clearCache = function() {
    console.log('üßπ [DEBUG] Manually clearing cache...');
    refreshDashboardData();
  };

  /**
   * Initialize the application with cache-based data loading
   */
  function initializeApp() {
    showLoading('Initializing application...');
    
    // Try to load dashboard data from cache first
    loadDashboardData();
  }

  /**
   * Load dashboard data - simplified flow with better logging
   */
  function loadDashboardData() {
    console.log('üöÄ [Client] Starting dashboard data load...');
    AppState.cacheLoading = true;
    
    // Step 1: Try server-side cache first
    console.log('üîç [Client] Checking server cache...');
    callServerFunction('getCachedDashboardData')
      .then(cacheResult => {
        console.log('üì• [Client] Cache check result:', cacheResult.success ? '‚úÖ Found' : '‚ùå Not found');
        
        if (cacheResult.success) {
          // Cache hit - use cached data
          console.log('üéâ [Client] Using cached dashboard data');
          console.log('üìä [Client] Cache contains:', cacheResult.data?.classrooms?.length || 0, 'classrooms');
          
          AppState.dashboardCache = cacheResult.data;
          AppState.cacheError = null;
          AppState.cacheLoading = false;
          
          initializeUIFromCache();
          hideLoading();
        } else {
          // Cache miss or expired - fetch fresh data
          console.log('üîÑ [Client] Cache invalid, fetching fresh data...');
          fetchAndCacheData();
        }
      })
      .catch(error => {
        console.error('‚ùå [Client] Error checking cache:', error);
        console.log('üîÑ [Client] Falling back to fresh data fetch...');
        fetchAndCacheData();
      });
  }

  /**
   * Fetch fresh data and cache it server-side - simplified with better logging
   */
  function fetchAndCacheData() {
    console.log('üì° [Client] Fetching fresh dashboard data...');
    
    callServerFunction('fetchAndCacheDashboardData')
      .then(result => {
        AppState.cacheLoading = false;
        hideLoading();
        
        console.log('üì¶ [Client] Fresh data fetch result:', result.success ? '‚úÖ Success' : '‚ùå Failed');
        
        if (result.success) {
          console.log('üéâ [Client] Fresh data loaded successfully!');
          console.log('üìä [Client] Data source:', result.source);
          console.log('üìä [Client] Contains:', result.data?.classrooms?.length || 0, 'classrooms');
          console.log('üíæ [Client] Server cache saved:', result.cached ? '‚úÖ Yes' : '‚ùå No');
          
          if (result.cacheError) {
            console.warn('‚ö†Ô∏è [Client] Cache save had issues:', result.cacheError);
          }
          
          AppState.dashboardCache = result.data;
          AppState.cacheError = null;
          
          // Initialize UI
          initializeUIFromCache();
        } else {
          console.error('‚ùå [Client] Failed to load dashboard data:', result.error);
          AppState.cacheError = result.error;
          showError('Failed to load dashboard data: ' + result.error);
        }
      })
      .catch(error => {
        AppState.cacheLoading = false;
        hideLoading();
        console.error('‚ùå [Client] Exception during data fetch:', error);
        AppState.cacheError = error.message;
        showError('Error loading dashboard data: ' + error.message);
      });
  }

  /**
   * Initialize UI components from cached dashboard data
   */
  function initializeUIFromCache() {
    if (!AppState.dashboardCache) {
      console.error('Cannot initialize UI: no dashboard cache available');
      return;
    }
    
    console.log('Initializing UI from cache...');
    
    // Set user info
    const teacher = AppState.dashboardCache.teacher;
    if (teacher) {
      document.getElementById('user-name').textContent = teacher.name || teacher.email;
    }
    
    // Populate classroom dropdown
    populateClassroomSelectFromCache();
    
    // Show welcome screen
    showWelcomeScreen();
    
    // Update global stats if available
    updateGlobalStatsFromCache();
    
    console.log('UI initialized successfully from cache');
  }

  /**
   * Refresh dashboard data (clear server-side cache and reload)
   */
  function refreshDashboardData() {
    console.log('Refreshing dashboard data...');
    
    showLoading('Clearing cache and refreshing data...');
    
    // Clear server-side cache first
    callServerFunction('clearDashboardCache')
      .then(clearResult => {
        console.log('Cache clear result:', clearResult);
        
        // Reset client state
        AppState.dashboardCache = null;
        AppState.cacheError = null;
        
        // Fetch fresh data
        fetchAndCacheData();
      })
      .catch(error => {
        console.error('Error clearing cache:', error);
        // Even if clearing cache fails, try to fetch fresh data
        AppState.dashboardCache = null;
        fetchAndCacheData();
      });
  }

  /**
   * Populate the classroom dropdown from cache
   */
  function populateClassroomSelectFromCache() {
    const select = document.getElementById('classroom-select');
    select.innerHTML = '<option value="">Select a classroom...</option>';
    
    if (!AppState.dashboardCache || !AppState.dashboardCache.classrooms) {
      console.warn('No classrooms available in cache');
      return;
    }
    
    AppState.dashboardCache.classrooms.forEach(classroom => {
      const option = document.createElement('option');
      option.value = classroom.id;
      option.textContent = classroom.name;
      select.appendChild(option);
    });
    
    console.log(`Populated ${AppState.dashboardCache.classrooms.length} classrooms in dropdown`);
  }

  /**
   * Legacy function for backward compatibility
   * @deprecated Use populateClassroomSelectFromCache instead
   */
  function populateClassroomSelect() {
    console.warn('populateClassroomSelect is deprecated, using cache version');
    populateClassroomSelectFromCache();
  }

  /**
   * Handle classroom selection change - now uses cache
   */
  function onClassroomChange() {
    const select = document.getElementById('classroom-select');
    const classroomId = select.value;
    
    console.log('üè´ [Client] Classroom selection changed:', classroomId);
    
    if (!classroomId) {
      console.log('üìù [Client] No classroom selected, clearing assignments');
      clearAssignmentsList();
      showWelcomeScreen();
      return;
    }
    
    // Debug: Log cache state
    console.log('üíæ [Client] Dashboard cache state:', {
      hasCache: !!AppState.dashboardCache,
      hasClassrooms: !!AppState.dashboardCache?.classrooms,
      classroomCount: AppState.dashboardCache?.classrooms?.length || 0
    });
    
    // Find classroom in cache
    AppState.currentClassroom = getClassroomFromCache(classroomId);
    AppState.currentAssignment = null;
    
    if (!AppState.currentClassroom) {
      console.error('‚ùå [Client] Classroom not found in cache:', classroomId);
      showError(`Classroom ${classroomId} not found in cache`);
      return;
    }
    
    console.log('‚úÖ [Client] Found classroom in cache:', {
      id: AppState.currentClassroom.id,
      name: AppState.currentClassroom.name,
      assignmentCount: AppState.currentClassroom.assignments?.length || 0,
      studentCount: AppState.currentClassroom.students?.length || 0,
      submissionCount: AppState.currentClassroom.submissions?.length || 0
    });
    
    // Load assignments from cache (instant)
    loadAssignmentsFromCache(classroomId);
  }

  /**
   * Load assignments for selected classroom from cache
   */
  function loadAssignmentsFromCache(classroomId) {
    console.log('üìö [Client] Loading assignments from cache for classroom:', classroomId);
    
    const classroom = getClassroomFromCache(classroomId);
    if (!classroom) {
      console.error('‚ùå [Client] Classroom not found in cache');
      showError('Classroom not found in cache');
      return;
    }
    
    // Get assignments from cache
    const assignments = classroom.assignments || [];
    const submissions = classroom.submissions || [];
    
    console.log('üìä [Client] Raw assignment data:', {
      assignmentCount: assignments.length,
      submissionCount: submissions.length,
      assignmentTitles: assignments.map(a => a.title || a.id).slice(0, 3)
    });
    
    // CRITICAL FIX: Populate AppState.submissions for UI compatibility
    AppState.submissions = submissions;
    console.log('‚úÖ [Client] Populated AppState.submissions:', AppState.submissions.length);
    
    // Calculate submission stats for each assignment
    const assignmentsWithStats = assignments.map(assignment => {
      const assignmentSubmissions = submissions.filter(s => s.assignmentId === assignment.id);
      const submissionStats = {
        total: assignmentSubmissions.length,
        graded: assignmentSubmissions.filter(s => s.status === 'graded').length,
        pending: assignmentSubmissions.filter(s => s.status === 'pending' || s.status === 'submitted').length,
        grading: assignmentSubmissions.filter(s => s.status === 'grading').length
      };
      
      console.log(`üìà [Client] Assignment "${assignment.title}" stats:`, submissionStats);
      
      return {
        ...assignment,
        submissionStats: submissionStats
      };
    });
    
    console.log('üéØ [Client] Assignments with calculated stats:', assignmentsWithStats.length);
    
    // Display immediately (no loading state needed)
    displayAssignments(assignmentsWithStats);
    updateQuickStats(assignmentsWithStats);
    
    console.log(`‚úÖ [Client] Successfully loaded ${assignments.length} assignments from cache`);
  }

  /**
   * Load assignments for selected classroom (legacy API version)
   * @deprecated Use loadAssignmentsFromCache for better performance
   */
  function loadAssignments(classroomId) {
    console.warn('loadAssignments API call - consider using cache version');
    showAssignmentsLoading();
    AppState.lastAction = () => loadAssignments(classroomId);
    
    callServerFunction('getAssignments', classroomId)
      .then(result => {
        if (result.success) {
          displayAssignments(result.data);
          updateQuickStats(result.data);
        } else {
          showError('Failed to load assignments: ' + result.error);
        }
      })
      .catch(error => {
        showError('Error loading assignments: ' + error.message);
      });
  }

  /**
   * Get classroom data from cache by ID
   */
  function getClassroomFromCache(classroomId) {
    console.log('üîç [Client] Looking for classroom in cache:', classroomId);
    
    if (!AppState.dashboardCache) {
      console.error('‚ùå [Client] No dashboard cache available');
      return null;
    }
    
    if (!AppState.dashboardCache.classrooms) {
      console.error('‚ùå [Client] No classrooms array in cache');
      return null;
    }
    
    console.log('üìö [Client] Searching through', AppState.dashboardCache.classrooms.length, 'cached classrooms');
    
    const classroom = AppState.dashboardCache.classrooms.find(c => c.id === classroomId);
    
    if (!classroom) {
      console.error('‚ùå [Client] Classroom not found:', classroomId);
      console.log('üîç [Client] Available classroom IDs:', AppState.dashboardCache.classrooms.map(c => c.id));
      return null;
    }
    
    // Validate classroom data structure
    const validation = {
      hasId: !!classroom.id,
      hasName: !!classroom.name,
      hasAssignments: Array.isArray(classroom.assignments),
      hasStudents: Array.isArray(classroom.students),
      hasSubmissions: Array.isArray(classroom.submissions),
      assignmentCount: classroom.assignments?.length || 0,
      submissionCount: classroom.submissions?.length || 0
    };
    
    console.log('‚úÖ [Client] Found classroom, validating structure:', validation);
    
    if (!validation.hasAssignments) {
      console.warn('‚ö†Ô∏è [Client] Classroom missing assignments array, adding empty array');
      classroom.assignments = [];
    }
    
    if (!validation.hasSubmissions) {
      console.warn('‚ö†Ô∏è [Client] Classroom missing submissions array, adding empty array');
      classroom.submissions = [];
    }
    
    return classroom;
  }

  /**
   * Update global statistics display from cache
   */
  function updateGlobalStatsFromCache() {
    if (!AppState.dashboardCache || !AppState.dashboardCache.globalStats) {
      return;
    }
    
    const stats = AppState.dashboardCache.globalStats;
    console.log('Global stats from cache:', stats);
    
    // Update stats in UI if elements exist
    const statsElements = {
      'total-classrooms': stats.totalClassrooms,
      'total-students': stats.totalStudents,
      'total-assignments': stats.totalAssignments,
      'ungraded-submissions': stats.ungradedSubmissions
    };
    
    Object.entries(statsElements).forEach(([elementId, value]) => {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = value || 0;
      }
    });
  }

  /**
   * Display assignments in sidebar
   */
  function displayAssignments(assignments) {
    console.log('üé® [Client] Displaying assignments:', {
      count: assignments?.length || 0,
      hasContainer: !!document.getElementById('assignments-list')
    });
    
    const container = document.getElementById('assignments-list');
    if (!container) {
      console.error('‚ùå [Client] assignments-list container not found!');
      return;
    }
    
    container.innerHTML = '';
    
    if (!assignments || assignments.length === 0) {
      console.log('üìù [Client] No assignments to display, showing empty message');
      container.innerHTML = '<div class="assignment-item empty-message">No assignments found</div>';
      return;
    }
    
    console.log('üèóÔ∏è [Client] Creating assignment items...');
    
    assignments.forEach((assignment, index) => {
      console.log(`üìã [Client] Creating item ${index + 1}:`, {
        id: assignment.id,
        title: assignment.title,
        type: assignment.type,
        hasStats: !!assignment.submissionStats,
        pending: assignment.submissionStats?.pending || 0
      });
      
      const item = createAssignmentItem(assignment);
      container.appendChild(item);
    });
    
    console.log(`‚úÖ [Client] Successfully displayed ${assignments.length} assignments`);
  }

  /**
   * Create assignment list item element
   */
  function createAssignmentItem(assignment) {
    const item = document.createElement('div');
    item.className = 'assignment-item';
    item.setAttribute('data-type', assignment.type);
    item.setAttribute('data-status', assignment.status);
    item.onclick = () => selectAssignment(assignment);
    
    // Add pending count badge if applicable
    const pendingCount = assignment.submissionStats ? assignment.submissionStats.pending : 0;
    const pendingBadge = pendingCount > 0 ? `<span class="pending-badge">${pendingCount}</span>` : '';
    
    item.innerHTML = `
      <div class="assignment-icon"></div>
      <div class="assignment-info">
        <div class="assignment-name">${escapeHtml(assignment.title)}</div>
        <div class="assignment-meta">${assignment.type} ‚Ä¢ ${assignment.maxScore || 100} pts</div>
      </div>
      <div class="assignment-status">${pendingBadge}</div>
    `;
    
    return item;
  }

  /**
   * Select an assignment and load its submissions - now uses cache
   */
  function selectAssignment(assignment) {
    // Update UI
    document.querySelectorAll('.assignment-item').forEach(item => {
      item.classList.remove('active');
    });
    event.currentTarget.classList.add('active');
    
    AppState.currentAssignment = assignment;
    AppState.selectedSubmissions.clear();
    
    // Show assignment view
    showAssignmentView();
    
    // Load submissions from cache (instant)
    loadSubmissionsFromCache(AppState.currentClassroom.id, assignment.id);
  }

  /**
   * Load submissions for selected assignment from cache
   */
  function loadSubmissionsFromCache(classroomId, assignmentId) {
    console.log('üîç [DEBUG] Loading submissions from cache for assignment:', assignmentId);
    console.log('üîç [DEBUG] Classroom ID:', classroomId);
    
    const classroom = getClassroomFromCache(classroomId);
    if (!classroom) {
      console.error('‚ùå [DEBUG] Classroom not found in cache for ID:', classroomId);
      showError('Classroom not found in cache');
      return;
    }
    
    console.log('‚úÖ [DEBUG] Classroom found:', classroom.name);
    console.log('üìä [DEBUG] Total submissions in classroom:', classroom.submissions?.length || 0);
    
    // Debug: Show all submission assignment IDs
    if (classroom.submissions) {
      const assignmentIds = classroom.submissions.map(s => s.assignmentId || 'NO_ID');
      console.log('üîç [DEBUG] All submission assignment IDs:', assignmentIds);
      console.log('üîç [DEBUG] Looking for assignment ID:', assignmentId);
      console.log('üîç [DEBUG] First few submissions:', classroom.submissions.slice(0, 2).map(s => ({
        id: s.id,
        assignmentId: s.assignmentId,
        studentName: s.studentName
      })));
    }
    
    // Filter submissions for this assignment from cache
    const submissions = classroom.submissions?.filter(s => s.assignmentId === assignmentId) || [];
    
    console.log(`üéØ [DEBUG] Found ${submissions.length} submissions for assignment ${assignmentId}`);
    if (submissions.length > 0) {
      console.log('üìù [DEBUG] First submission:', {
        id: submissions[0].id,
        studentName: submissions[0].studentName,
        assignmentId: submissions[0].assignmentId
      });
    }
    
    // Display immediately (no loading state needed)
    displaySubmissions(submissions);
    
    // Calculate and update stats
    const stats = calculateStats(submissions);
    updateSubmissionStats(stats);
    
    console.log(`‚úÖ [DEBUG] Loaded ${submissions.length} submissions from cache for assignment ${assignmentId}`);
  }

  /**
   * Load submissions for selected assignment (legacy API version)
   * @deprecated Use loadSubmissionsFromCache for better performance
   */
  function loadSubmissions(classroomId, assignmentId) {
    console.warn('loadSubmissions API call - consider using cache version');
    showLoading('Loading submissions...');
    AppState.lastAction = () => loadSubmissions(classroomId, assignmentId);
    
    callServerFunction('getSubmissions', classroomId, assignmentId)
      .then(result => {
        hideLoading();
        if (result.success) {
          displaySubmissions(result.data);
          updateSubmissionStats(result.stats || calculateStats(result.data));
        } else {
          showError('Failed to load submissions: ' + result.error);
        }
      })
      .catch(error => {
        hideLoading();
        showError('Error loading submissions: ' + error.message);
      });
  }

  /**
   * Calculate submission statistics
   */
  function calculateStats(submissions) {
    if (!submissions || submissions.length === 0) {
      return {
        total: 0,
        graded: 0,
        pending: 0,
        grading: 0
      };
    }
    
    return {
      total: submissions.length,
      graded: submissions.filter(s => s.status === 'graded').length,
      pending: submissions.filter(s => s.status === 'pending' || s.status === 'submitted').length,
      grading: submissions.filter(s => s.status === 'grading').length
    };
  }

  /**
   * Display submissions in the main content area
   */
  function displaySubmissions(submissions) {
    const container = document.getElementById('submissions-list');
    container.innerHTML = '';
    
    if (submissions.length === 0) {
      document.getElementById('submissions-container').style.display = 'none';
      document.getElementById('empty-state').style.display = 'block';
      return;
    }
    
    document.getElementById('empty-state').style.display = 'none';
    document.getElementById('submissions-container').style.display = 'block';
    
    submissions.forEach((submission, index) => {
      const item = createSubmissionItem(submission, index);
      container.appendChild(item);
    });
    
    updateBatchGradeButton();
  }

  /**
   * Create submission list item element
   */
  function createSubmissionItem(submission, index) {
    const item = document.createElement('div');
    item.className = 'submission-item';
    item.setAttribute('data-status', submission.status);
    if (AppState.selectedSubmissions.has(submission.id)) {
      item.classList.add('selected');
    }
    
    const scoreDisplay = submission.score !== undefined ? 
      `<div class="submission-score">${submission.score}/${submission.maxScore || AppState.currentAssignment.maxScore || 100}</div>` : '';
    
    const lateIndicator = submission.late ? '<span class="late-indicator">Late</span>' : '';
    
    // Add feedback preview for graded submissions
    let feedbackPreview = '';
    if (submission.feedback && submission.status === 'graded') {
      let previewText = '';
      if (typeof submission.feedback === 'string') {
        previewText = submission.feedback.substring(0, 80);
      } else if (submission.feedback.summary) {
        previewText = submission.feedback.summary.substring(0, 80);
      }
      
      if (previewText) {
        feedbackPreview = `<div class="feedback-preview" title="${escapeHtml(previewText)}">
          üí¨ ${escapeHtml(previewText)}${previewText.length > 80 ? '...' : ''}
        </div>`;
      }
    }
    
    item.innerHTML = `
      <div class="submission-checkbox">
        <input type="checkbox" ${AppState.selectedSubmissions.has(submission.id) ? 'checked' : ''} 
               onchange="toggleSubmissionSelection('${submission.id}')">
      </div>
      <div class="submission-info" onclick="openSubmissionGrading(${index})">
        <div class="student-name">${escapeHtml(submission.studentName)}</div>
        <div class="submission-time">
          Submitted: ${formatDate(submission.submittedAt)}
          ${lateIndicator}
        </div>
        ${feedbackPreview}
      </div>
      <div class="submission-status ${getStatusClass(submission.status)}">${getStatusText(submission.status)}</div>
      ${scoreDisplay}
    `;
    
    return item;
  }

  /**
   * Toggle submission selection for batch operations
   */
  function toggleSubmissionSelection(submissionId) {
    if (AppState.selectedSubmissions.has(submissionId)) {
      AppState.selectedSubmissions.delete(submissionId);
    } else {
      AppState.selectedSubmissions.add(submissionId);
    }
    
    updateSubmissionItemSelection(submissionId);
    updateSelectAllCheckbox();
    updateBatchGradeButton();
  }

  /**
   * Toggle select all submissions
   */
  function toggleSelectAll() {
    const selectAllCheckbox = document.getElementById('select-all');
    const pendingSubmissions = AppState.submissions.filter(s => s.status === 'pending');
    
    if (selectAllCheckbox.checked) {
      // Select all pending submissions
      pendingSubmissions.forEach(submission => {
        AppState.selectedSubmissions.add(submission.id);
      });
    } else {
      // Deselect all
      AppState.selectedSubmissions.clear();
    }
    
    // Update UI
    document.querySelectorAll('.submission-item input[type="checkbox"]').forEach(checkbox => {
      const submissionId = checkbox.onchange.toString().match(/'([^']+)'/)[1];
      const submission = AppState.submissions.find(s => s.id === submissionId);
      if (submission && submission.status === 'pending') {
        checkbox.checked = selectAllCheckbox.checked;
        updateSubmissionItemSelection(submissionId);
      }
    });
    
    updateBatchGradeButton();
  }

  /**
   * Open grading modal for specific submission
   */
  function openSubmissionGrading(index) {
    AppState.currentSubmissionIndex = index;
    const submission = AppState.submissions[index];
    
    // Populate modal with submission data
    document.getElementById('modal-assignment-title').textContent = 
      `Grade: ${AppState.currentAssignment.title}`;
    document.getElementById('modal-student-name').textContent = submission.studentName;
    document.getElementById('modal-submission-time').textContent = 
      `Submitted: ${formatDate(submission.submittedAt)}`;
    document.getElementById('modal-status-badge').textContent = getStatusText(submission.status);
    document.getElementById('modal-status-badge').className = 
      `submission-status-badge ${getStatusClass(submission.status)}`;
    
    // Show/hide late indicator
    const lateIndicator = document.getElementById('modal-late-indicator');
    if (submission.late) {
      lateIndicator.style.display = 'inline';
    } else {
      lateIndicator.style.display = 'none';
    }
    
    // Populate content based on assignment type
    populateSubmissionContent(submission);
    
    // Populate existing grade if available
    if (submission.score !== undefined) {
      document.getElementById('score-input').value = submission.score;
      updatePercentageDisplay();
    } else {
      document.getElementById('score-input').value = '';
      document.getElementById('percentage-display').textContent = '0%';
    }
    
    if (submission.feedback) {
      // Handle feedback as either string or object
      if (typeof submission.feedback === 'string') {
        document.getElementById('feedback-input').value = submission.feedback;
      } else if (typeof submission.feedback === 'object' && submission.feedback !== null) {
        // Format structured feedback
        let formattedFeedback = '';
        
        if (submission.feedback.summary) {
          formattedFeedback += submission.feedback.summary + '\n\n';
        }
        
        if (submission.feedback.strengths && submission.feedback.strengths.length > 0) {
          formattedFeedback += 'Strengths:\n';
          submission.feedback.strengths.forEach(strength => {
            formattedFeedback += '‚Ä¢ ' + strength + '\n';
          });
          formattedFeedback += '\n';
        }
        
        if (submission.feedback.improvements && submission.feedback.improvements.length > 0) {
          formattedFeedback += 'Areas for Improvement:\n';
          submission.feedback.improvements.forEach(improvement => {
            formattedFeedback += '‚Ä¢ ' + improvement + '\n';
          });
          formattedFeedback += '\n';
        }
        
        if (submission.feedback.suggestions && submission.feedback.suggestions.length > 0) {
          formattedFeedback += 'Suggestions:\n';
          submission.feedback.suggestions.forEach(suggestion => {
            formattedFeedback += '‚Ä¢ ' + suggestion + '\n';
          });
        }
        
        document.getElementById('feedback-input').value = formattedFeedback.trim();
      } else {
        document.getElementById('feedback-input').value = String(submission.feedback);
      }
    } else {
      document.getElementById('feedback-input').value = '';
    }
    
    // Update navigation buttons
    updateModalNavigation();
    
    // Clear AI suggestions
    hideAISuggestions();
    
    // Show modal
    document.getElementById('grading-modal').style.display = 'flex';
  }

  /**
   * Populate submission content in modal
   */
  function populateSubmissionContent(submission) {
    // Hide all content containers
    document.getElementById('code-container').style.display = 'none';
    document.getElementById('quiz-container').style.display = 'none';
    document.getElementById('content-container').style.display = 'none';
    
    if (AppState.currentAssignment.type === 'coding' && typeof submission.content === 'string') {
      // Show code container
      document.getElementById('code-container').style.display = 'block';
      document.getElementById('code-content').textContent = submission.content;
    } else if (AppState.currentAssignment.type === 'quiz' && submission.content && submission.content.answers) {
      // Show quiz container
      document.getElementById('quiz-container').style.display = 'block';
      populateQuizAnswers(submission.content.answers);
    } else {
      // Show general content container
      document.getElementById('content-container').style.display = 'block';
      document.getElementById('content-text').textContent = 
        typeof submission.content === 'string' ? submission.content : JSON.stringify(submission.content, null, 2);
    }
  }

  /**
   * Populate quiz answers in modal
   */
  function populateQuizAnswers(answers) {
    const container = document.getElementById('quiz-answers');
    container.innerHTML = '';
    
    answers.forEach((answer, index) => {
      const answerDiv = document.createElement('div');
      answerDiv.className = 'quiz-answer';
      
      const correctIndicator = answer.correct !== undefined ? 
        (answer.correct ? ' ‚úì' : ' ‚úó') : '';
      
      answerDiv.innerHTML = `
        <div class="quiz-question">Question ${index + 1}${correctIndicator}</div>
        <div class="quiz-student-answer">${escapeHtml(answer.answer || 'No answer provided')}</div>
      `;
      
      container.appendChild(answerDiv);
    });
  }

  /**
   * Grade submission with AI
   */
  function gradeWithAI() {
    const submission = AppState.submissions[AppState.currentSubmissionIndex];
    if (!submission) return;
    
    // Show progress
    showAIProgress();
    
    // Update submission status to grading
    updateSubmissionStatus(submission.id, 'grading');
    
    const submissionData = {
      id: submission.id,
      studentId: submission.studentId,
      assignmentId: AppState.currentAssignment.id,
      type: AppState.currentAssignment.type,
      content: submission.content,
      maxScore: AppState.currentAssignment.maxScore || 100
    };
    
    callServerFunction('gradeSubmission', submissionData)
      .then(result => {
        hideAIProgress();
        
        if (result.success) {
          const gradeData = result.data;
          
          // Extract score and feedback from grade structure
          const score = gradeData.grade ? gradeData.grade.score : gradeData.score;
          const feedback = gradeData.feedback;
          const gradedAt = gradeData.metadata ? gradeData.metadata.gradedAt : gradeData.gradedAt;
          
          // Update form with AI results
          document.getElementById('score-input').value = score;
          
          // Format and display feedback
          if (typeof feedback === 'object' && feedback !== null) {
            let formattedFeedback = '';
            if (feedback.summary) formattedFeedback += feedback.summary + '\n\n';
            if (feedback.strengths && feedback.strengths.length > 0) {
              formattedFeedback += 'Strengths:\n';
              feedback.strengths.forEach(s => formattedFeedback += '‚Ä¢ ' + s + '\n');
              formattedFeedback += '\n';
            }
            if (feedback.improvements && feedback.improvements.length > 0) {
              formattedFeedback += 'Areas for Improvement:\n';
              feedback.improvements.forEach(i => formattedFeedback += '‚Ä¢ ' + i + '\n');
            }
            document.getElementById('feedback-input').value = formattedFeedback.trim();
          } else {
            document.getElementById('feedback-input').value = feedback || '';
          }
          
          updatePercentageDisplay();
          
          // Show AI suggestions
          showAISuggestions(gradeData);
          
          // Update submission in memory with proper status management
          submission.score = score;
          submission.feedback = feedback;
          submission.status = 'graded';
          submission.gradedAt = gradedAt;
          submission.gradedBy = 'ai';
          
          // Log the update for debugging
          console.log(`‚úÖ Single grading completed for ${submission.id}:`, {
            student: submission.studentName,
            score: score,
            status: submission.status,
            hasFeedback: !!feedback
          });
          
          // Auto-save to cache
          showToast('Saving grade to cache...', 'info');
          
          const gradedSubmission = {
            id: submission.id,
            score: score,
            feedback: feedback,
            status: 'graded',
            gradedAt: gradedAt,
            gradedBy: 'ai'
          };
          
          callServerFunction('updateGradedSubmissionsInCache', 
            AppState.currentClassroom.id, 
            [gradedSubmission]
          ).then(cacheResult => {
            if (cacheResult.success) {
              showToast('AI grading completed and saved!', 'success');
              console.log('‚úÖ Grade auto-saved to cache:', cacheResult.updatedCount, 'submission(s)');
            } else {
              showToast('AI grading completed (cache save failed)', 'warning');
              console.error('‚ùå Cache save failed:', cacheResult.error);
            }
          }).catch(error => {
            console.error('‚ùå Cache save error:', error);
            showToast('AI grading completed (cache save error)', 'warning');
          });
          
          // Refresh submissions display
          displaySubmissions(AppState.submissions);
        } else {
          showToast('AI grading failed: ' + result.error, 'error');
          updateSubmissionStatus(submission.id, 'pending');
        }
      })
      .catch(error => {
        hideAIProgress();
        showToast('AI grading error: ' + error.message, 'error');
        updateSubmissionStatus(submission.id, 'pending');
      });
  }

  /**
   * Batch grade selected submissions
   */
  function batchGradeSelected() {
    const selectedSubmissions = Array.from(AppState.selectedSubmissions)
      .map(id => AppState.submissions.find(s => s.id === id))
      .filter(s => s && s.status === 'pending');
    
    if (selectedSubmissions.length === 0) {
      showToast('No pending submissions selected', 'warning');
      return;
    }
    
    if (!confirm(`Grade ${selectedSubmissions.length} submissions with AI?`)) {
      return;
    }
    
    // Update UI to show batch progress
    showBatchProgress(selectedSubmissions.length);
    
    // Update all selected submissions to grading status
    selectedSubmissions.forEach(submission => {
      updateSubmissionStatus(submission.id, 'grading');
    });
    
    const submissionsData = selectedSubmissions.map(submission => ({
      id: submission.id,
      studentId: submission.studentId,
      assignmentId: AppState.currentAssignment.id,
      type: AppState.currentAssignment.type,
      content: submission.content,
      maxScore: AppState.currentAssignment.maxScore || 100
    }));
    
    callServerFunction('batchGrade', submissionsData)
      .then(result => {
        hideBatchProgress();
        
        if (result.success) {
          const results = result.data.results || [];
          
          // Update submissions in memory with proper status management
          results.forEach(gradeResult => {
            const submission = AppState.submissions.find(s => s.id === gradeResult.submissionId);
            if (submission) {
              // Extract score from grade object
              submission.score = gradeResult.grade ? gradeResult.grade.score : gradeResult.score;
              submission.feedback = gradeResult.feedback;
              submission.status = 'graded';
              submission.gradedAt = gradeResult.metadata ? gradeResult.metadata.gradedAt : gradeResult.gradedAt;
              submission.gradedBy = 'ai';
              
              // Log the update for debugging
              console.log(`‚úÖ Updated submission ${gradeResult.submissionId}:`, {
                student: submission.studentName,
                score: submission.score,
                status: submission.status,
                hasFeedback: !!submission.feedback
              });
            } else {
              console.error(`‚ùå Submission not found for update: ${gradeResult.submissionId}`);
            }
          });
          
          // Prepare graded submissions for cache update
          const gradedSubmissions = results.map(gradeResult => ({
            id: gradeResult.submissionId,
            score: gradeResult.grade ? gradeResult.grade.score : gradeResult.score,
            feedback: gradeResult.feedback,
            status: 'graded',
            gradedAt: gradeResult.metadata ? gradeResult.metadata.gradedAt : gradeResult.gradedAt,
            gradedBy: 'ai'
          }));
          
          // Clear selections and refresh display
          AppState.selectedSubmissions.clear();
          displaySubmissions(AppState.submissions);
          updateSubmissionStats(calculateStats(AppState.submissions));
          
          // Auto-save all graded submissions to cache
          showToast('Saving batch grades to cache...', 'info');
          
          callServerFunction('updateGradedSubmissionsInCache', 
            AppState.currentClassroom.id, 
            gradedSubmissions
          ).then(cacheResult => {
            if (cacheResult.success) {
              showToast(`Successfully graded ${results.length} submissions and saved to cache!`, 'success');
              console.log('‚úÖ Batch grades auto-saved to cache:', cacheResult.updatedCount, 'submission(s)');
            } else {
              showToast(`Graded ${results.length} submissions (cache save failed)`, 'warning');
              console.error('‚ùå Cache save failed:', cacheResult.error);
            }
          }).catch(error => {
            console.error('‚ùå Cache save error:', error);
            showToast(`Graded ${results.length} submissions (cache save error)`, 'warning');
          });
        } else {
          showToast('Batch grading failed: ' + result.error, 'error');
          // Reset failed submissions back to pending
          selectedSubmissions.forEach(submission => {
            updateSubmissionStatus(submission.id, 'pending');
          });
        }
      })
      .catch(error => {
        hideBatchProgress();
        showToast('Batch grading error: ' + error.message, 'error');
        // Reset failed submissions back to pending
        selectedSubmissions.forEach(submission => {
          updateSubmissionStatus(submission.id, 'pending');
        });
      });
  }

  /**
   * Save grade and close modal
   */
  function saveGradeAndClose() {
    const submission = AppState.submissions[AppState.currentSubmissionIndex];
    if (!submission) return;
    
    const score = parseInt(document.getElementById('score-input').value);
    const feedback = document.getElementById('feedback-input').value.trim();
    
    if (isNaN(score) || score < 0) {
      showToast('Please enter a valid score', 'warning');
      return;
    }
    
    const maxScore = AppState.currentAssignment.maxScore || 100;
    if (score > maxScore) {
      showToast(`Score cannot exceed ${maxScore}`, 'warning');
      return;
    }
    
    const gradeData = {
      score: score,
      feedback: feedback,
      gradedBy: 'teacher',
      gradedAt: new Date().toISOString()
    };
    
    // Show saving state
    const saveBtn = document.getElementById('save-btn');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;
    
    callServerFunction('updateGrade', 
      AppState.currentClassroom.id, 
      AppState.currentAssignment.id, 
      submission.id, 
      gradeData
    ).then(result => {
      saveBtn.textContent = originalText;
      saveBtn.disabled = false;
      
      if (result.success) {
        // Update submission in memory
        submission.score = score;
        submission.feedback = feedback;
        submission.status = 'graded';
        submission.gradedAt = gradeData.gradedAt;
        
        // Refresh display
        displaySubmissions(AppState.submissions);
        updateSubmissionStats(calculateStats(AppState.submissions));
        
        // Close modal
        closeGradingModal();
        
        showToast('Grade saved successfully!', 'success');
      } else {
        showToast('Failed to save grade: ' + result.error, 'error');
      }
    }).catch(error => {
      saveBtn.textContent = originalText;
      saveBtn.disabled = false;
      showToast('Error saving grade: ' + error.message, 'error');
    });
  }

  /**
   * Close grading modal
   */
  function closeGradingModal() {
    document.getElementById('grading-modal').style.display = 'none';
    AppState.currentSubmissionIndex = -1;
    hideAISuggestions();
    hideAIProgress();
  }

  /**
   * Navigate to previous submission
   */
  function previousSubmission() {
    if (AppState.currentSubmissionIndex > 0) {
      openSubmissionGrading(AppState.currentSubmissionIndex - 1);
    }
  }

  /**
   * Navigate to next submission
   */
  function nextSubmission() {
    if (AppState.currentSubmissionIndex < AppState.submissions.length - 1) {
      openSubmissionGrading(AppState.currentSubmissionIndex + 1);
    }
  }

  /**
   * Export grades for current assignment
   */
  function exportCurrentGrades() {
    if (!AppState.currentAssignment) {
      showToast('No assignment selected', 'warning');
      return;
    }
    
    callServerFunction('exportGradesForAssignment', 
      AppState.currentClassroom.id, 
      AppState.currentAssignment.id
    ).then(result => {
      if (result.success) {
        downloadCSV(result.data, result.filename);
        showToast('Grades exported successfully!', 'success');
      } else {
        showToast('Export failed: ' + result.error, 'error');
      }
    }).catch(error => {
      showToast('Export error: ' + error.message, 'error');
    });
  }

  /**
   * Refresh current submissions
   */
  function refreshSubmissions() {
    if (AppState.currentAssignment && AppState.currentClassroom) {
      loadSubmissions(AppState.currentClassroom.id, AppState.currentAssignment.id);
    }
  }

  /**
   * Refresh all data
   */
  function refreshAllData() {
    initializeApp();
  }

  /**
   * Retry last failed action
   */
  function retryLastAction() {
    if (AppState.lastAction) {
      hideError();
      AppState.lastAction();
    }
  }

  /**
   * Filter submissions by status
   */
  function filterSubmissions() {
    const filter = document.getElementById('status-filter').value;
    const items = document.querySelectorAll('.submission-item');
    
    items.forEach(item => {
      const status = item.getAttribute('data-status');
      if (filter === 'all' || status === filter) {
        item.style.display = 'flex';
      } else {
        item.style.display = 'none';
      }
    });
  }

  // Utility Functions

  /**
   * Call server-side function with error handling
   */
  function callServerFunction(functionName, ...args) {
    return new Promise((resolve, reject) => {
      const handler = google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject);
      
      handler[functionName](...args);
    });
  }

  /**
   * Show loading state
   */
  function showLoading(message = 'Loading...') {
    document.getElementById('loading-message').textContent = message;
    document.getElementById('loading').style.display = 'flex';
    document.getElementById('welcome-screen').style.display = 'none';
    document.getElementById('assignment-view').style.display = 'none';
    document.getElementById('error').style.display = 'none';
  }

  /**
   * Hide loading state
   */
  function hideLoading() {
    document.getElementById('loading').style.display = 'none';
  }

  /**
   * Show error state
   */
  function showError(message) {
    document.getElementById('error-message').textContent = message;
    document.getElementById('error').style.display = 'flex';
    document.getElementById('loading').style.display = 'none';
    document.getElementById('welcome-screen').style.display = 'none';
    document.getElementById('assignment-view').style.display = 'none';
  }

  /**
   * Hide error state
   */
  function hideError() {
    document.getElementById('error').style.display = 'none';
  }

  /**
   * Show welcome screen
   */
  function showWelcomeScreen() {
    document.getElementById('welcome-screen').style.display = 'block';
    document.getElementById('assignment-view').style.display = 'none';
    document.getElementById('loading').style.display = 'none';
    document.getElementById('error').style.display = 'none';
  }

  /**
   * Show assignment view
   */
  function showAssignmentView() {
    document.getElementById('assignment-view').style.display = 'block';
    document.getElementById('welcome-screen').style.display = 'none';
    document.getElementById('loading').style.display = 'none';
    document.getElementById('error').style.display = 'none';
    
    // Update assignment header
    if (AppState.currentAssignment) {
      document.getElementById('assignment-title').textContent = AppState.currentAssignment.title;
    }
  }

  /**
   * Show assignments loading in sidebar
   */
  function showAssignmentsLoading() {
    const container = document.getElementById('assignments-list');
    container.innerHTML = '<div class="assignments-loading"><div class="spinner"></div>Loading assignments...</div>';
  }

  /**
   * Clear assignments list
   */
  function clearAssignmentsList() {
    const container = document.getElementById('assignments-list');
    container.innerHTML = '<div class="assignment-item empty-message">Select a classroom to view assignments</div>';
  }

  /**
   * Update quick stats in sidebar
   */
  function updateQuickStats(assignments) {
    const totalAssignments = assignments.length;
    const pendingGrades = assignments.reduce((count, assignment) => {
      return count + (assignment.submissionStats ? assignment.submissionStats.pending : 0);
    }, 0);
    
    document.getElementById('total-assignments').textContent = totalAssignments;
    document.getElementById('pending-grades').textContent = pendingGrades;
  }

  /**
   * Update submission statistics display
   */
  function updateSubmissionStats(stats) {
    document.getElementById('stat-submitted').textContent = stats.total || 0;
    document.getElementById('stat-graded').textContent = stats.graded || 0;
    document.getElementById('stat-pending').textContent = stats.pending || 0;
    document.getElementById('stat-average').textContent = (stats.averageScore || 0) + '%';
    
    document.getElementById('stats-container').style.display = 'grid';
  }

  /**
   * Calculate statistics from submissions array
   */
  function calculateStats(submissions) {
    const total = submissions.length;
    const graded = submissions.filter(s => s.status === 'graded').length;
    const pending = submissions.filter(s => s.status === 'pending').length;
    const grading = submissions.filter(s => s.status === 'grading').length;
    
    const gradedSubmissions = submissions.filter(s => s.status === 'graded' && s.score !== undefined);
    const averageScore = gradedSubmissions.length > 0 
      ? Math.round(gradedSubmissions.reduce((sum, s) => sum + s.score, 0) / gradedSubmissions.length)
      : 0;
    
    return { total, graded, pending, grading, averageScore };
  }

  /**
   * Update batch grade button state
   */
  function updateBatchGradeButton() {
    const button = document.getElementById('batch-grade-btn');
    const selectedCount = AppState.selectedSubmissions.size;
    const pendingSelected = Array.from(AppState.selectedSubmissions)
      .map(id => AppState.submissions.find(s => s.id === id))
      .filter(s => s && s.status === 'pending').length;
    
    button.disabled = pendingSelected === 0;
    button.textContent = selectedCount > 0 
      ? `ü§ñ Grade Selected (${pendingSelected})` 
      : 'ü§ñ Batch Grade Selected';
  }

  /**
   * Update select all checkbox state
   */
  function updateSelectAllCheckbox() {
    const selectAllCheckbox = document.getElementById('select-all');
    const pendingSubmissions = AppState.submissions.filter(s => s.status === 'pending');
    const selectedPending = Array.from(AppState.selectedSubmissions)
      .map(id => AppState.submissions.find(s => s.id === id))
      .filter(s => s && s.status === 'pending').length;
    
    selectAllCheckbox.checked = pendingSubmissions.length > 0 && 
                                selectedPending === pendingSubmissions.length;
  }

  /**
   * Update submission item selection visual state
   */
  function updateSubmissionItemSelection(submissionId) {
    const items = document.querySelectorAll('.submission-item');
    items.forEach(item => {
      const checkbox = item.querySelector('input[type="checkbox"]');
      const id = checkbox.onchange.toString().match(/'([^']+)'/)[1];
      if (id === submissionId) {
        checkbox.checked = AppState.selectedSubmissions.has(submissionId);
        if (AppState.selectedSubmissions.has(submissionId)) {
          item.classList.add('selected');
        } else {
          item.classList.remove('selected');
        }
      }
    });
  }

  /**
   * Update submission status in UI
   */
  function updateSubmissionStatus(submissionId, status) {
    // Update in memory
    const submission = AppState.submissions.find(s => s.id === submissionId);
    if (submission) {
      submission.status = status;
    }
    
    // Update server
    callServerFunction('updateSubmissionStatus', submissionId, status);
    
    // Update UI
    const items = document.querySelectorAll('.submission-item');
    items.forEach(item => {
      const checkbox = item.querySelector('input[type="checkbox"]');
      if (checkbox) {
        const id = checkbox.onchange.toString().match(/'([^']+)'/)[1];
        if (id === submissionId) {
          item.setAttribute('data-status', status);
          const statusElement = item.querySelector('.submission-status');
          if (statusElement) {
            statusElement.textContent = getStatusText(status);
            statusElement.className = `submission-status ${getStatusClass(status)}`;
          }
        }
      }
    });
  }

  /**
   * Show AI grading progress
   */
  function showAIProgress() {
    const progressDiv = document.getElementById('ai-progress');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    
    progressDiv.style.display = 'block';
    progressFill.style.width = '0%';
    progressText.textContent = 'Initializing AI grading...';
    
    // Simulate progress
    let progress = 0;
    const interval = setInterval(() => {
      progress += Math.random() * 15;
      if (progress > 90) progress = 90;
      
      progressFill.style.width = progress + '%';
      
      if (progress < 30) {
        progressText.textContent = 'Analyzing submission...';
      } else if (progress < 60) {
        progressText.textContent = 'Processing with AI...';
      } else {
        progressText.textContent = 'Generating feedback...';
      }
    }, 200);
    
    // Store interval for cleanup
    progressDiv.dataset.interval = interval;
  }

  /**
   * Hide AI grading progress
   */
  function hideAIProgress() {
    const progressDiv = document.getElementById('ai-progress');
    const interval = progressDiv.dataset.interval;
    
    if (interval) {
      clearInterval(interval);
    }
    
    progressDiv.style.display = 'none';
  }

  /**
   * Show AI suggestions in grading modal
   */
  function showAISuggestions(gradeData) {
    const suggestionsDiv = document.getElementById('ai-suggestions');
    const confidenceBadge = document.getElementById('confidence-badge');
    const suggestionContent = document.getElementById('suggestion-content');
    
    confidenceBadge.textContent = `Confidence: ${Math.round((gradeData.confidence || 0.85) * 100)}%`;
    suggestionContent.innerHTML = `
      <div><strong>Suggested Score:</strong> ${gradeData.score}/${AppState.currentAssignment.maxScore || 100}</div>
      <div><strong>AI Feedback:</strong> ${gradeData.feedback}</div>
    `;
    
    suggestionsDiv.style.display = 'block';
  }

  /**
   * Hide AI suggestions
   */
  function hideAISuggestions() {
    document.getElementById('ai-suggestions').style.display = 'none';
  }

  /**
   * Accept AI suggestions
   */
  function acceptAISuggestions() {
    // Values are already populated, just hide suggestions
    hideAISuggestions();
    showToast('AI suggestions accepted', 'success');
  }

  /**
   * Clear AI suggestions
   */
  function clearAISuggestions() {
    document.getElementById('score-input').value = '';
    document.getElementById('feedback-input').value = '';
    updatePercentageDisplay();
    hideAISuggestions();
  }

  /**
   * Update percentage display when score changes
   */
  function updatePercentageDisplay() {
    const score = parseInt(document.getElementById('score-input').value) || 0;
    const maxScore = AppState.currentAssignment ? (AppState.currentAssignment.maxScore || 100) : 100;
    const percentage = Math.round((score / maxScore) * 100);
    
    document.getElementById('percentage-display').textContent = percentage + '%';
    document.getElementById('max-score').textContent = maxScore;
  }

  /**
   * Update modal navigation buttons
   */
  function updateModalNavigation() {
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    
    prevBtn.disabled = AppState.currentSubmissionIndex <= 0;
    nextBtn.disabled = AppState.currentSubmissionIndex >= AppState.submissions.length - 1;
  }

  /**
   * Show batch grading progress
   */
  function showBatchProgress(total) {
    showToast(`Grading ${total} submissions with AI...`, 'info');
  }

  /**
   * Hide batch grading progress
   */
  function hideBatchProgress() {
    // Progress is shown via toast, nothing to hide
  }

  /**
   * Show toast notification
   */
  function showToast(message, type = 'info') {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    
    const icon = type === 'success' ? '‚úì' : 
                 type === 'error' ? '‚úó' : 
                 type === 'warning' ? '‚ö†' : '‚Ñπ';
    
    toast.innerHTML = `<span>${icon}</span><span>${escapeHtml(message)}</span>`;
    
    container.appendChild(toast);
    
    // Auto remove after 4 seconds
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 4000);
  }

  /**
   * Download CSV file
   */
  function downloadCSV(csvContent, filename) {
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  /**
   * Copy code to clipboard
   */
  function copyCode() {
    const codeContent = document.getElementById('code-content');
    const text = codeContent.textContent;
    
    if (navigator.clipboard) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('Code copied to clipboard!', 'success');
      });
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      showToast('Code copied to clipboard!', 'success');
    }
  }

  /**
   * Show settings modal (placeholder)
   */
  function showSettings() {
    showToast('Settings panel coming soon!', 'info');
  }

  /**
   * Export all grades (placeholder)
   */
  function exportAllGrades() {
    showToast('Export all grades coming soon!', 'info');
  }

  // Helper Functions

  function getStatusClass(status) {
    return `status-${status}`;
  }

  function getStatusText(status) {
    const statusMap = {
      'graded': 'Graded',
      'pending': 'Pending',
      'grading': 'Grading...'
    };
    return statusMap[status] || status;
  }

  function formatDate(dateString) {
    if (!dateString) return 'Unknown';
    return new Date(dateString).toLocaleDateString() + ' ' + 
           new Date(dateString).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // Event Listeners

  // Score input change
  document.addEventListener('DOMContentLoaded', function() {
    const scoreInput = document.getElementById('score-input');
    if (scoreInput) {
      scoreInput.addEventListener('input', updatePercentageDisplay);
    }
  });

  // Close modal on outside click
  window.onclick = function(event) {
    const modal = document.getElementById('grading-modal');
    if (event.target === modal) {
      closeGradingModal();
    }
  };

  // Keyboard shortcuts
  document.addEventListener('keydown', function(event) {
    // Only handle shortcuts when modal is open
    if (document.getElementById('grading-modal').style.display === 'flex') {
      if (event.key === 'Escape') {
        closeGradingModal();
      } else if (event.key === 'ArrowLeft' && event.ctrlKey) {
        event.preventDefault();
        previousSubmission();
      } else if (event.key === 'ArrowRight' && event.ctrlKey) {
        event.preventDefault();
        nextSubmission();
      } else if (event.key === 's' && event.ctrlKey) {
        event.preventDefault();
        saveGradeAndClose();
      }
    }
  });

  console.log('Roo Teacher Grading Portal - JavaScript loaded successfully');
</script>